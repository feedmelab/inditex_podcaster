{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { applyFilter, fetchPodcastDetails, fetchPodcasts } from \"../../utils/utils\";\nconst podcastSlice = createSlice({\n  name: \"podcast\",\n  initialState: {\n    podcasts: [],\n    status: \"idle\",\n    error: null,\n    lastFetch: null,\n    filter: \"\",\n    filteredPodcasts: [],\n    isFetchingDetails: false,\n    podcastDetails: null,\n    podcastDetailsCache: {},\n    summary: null,\n    downloadProgress: 0\n  },\n  reducers: {\n    updateFilter: (state, action) => {\n      state.filter = action.payload;\n      state.filteredPodcasts = applyFilter(state.podcasts, state.filter);\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchPodcasts.pending, state => {\n      state.status = \"loading\";\n    }).addCase(fetchPodcasts.fulfilled, (state, action) => {\n      let oneHourAgo = Date.now() - 60 * 60 * 1000;\n      if (state.lastFetch > oneHourAgo) {\n        state.filteredPodcasts = applyFilter(state.podcasts, state.filter);\n      } else {\n        // Descargamos y almacenamos los nuevos podcasts en la caché\n        state.podcasts = action.payload;\n        state.lastFetch = Date.now();\n        state.filteredPodcasts = applyFilter(action.payload, state.filter);\n      }\n      state.status = \"succeeded\";\n    }).addCase(fetchPodcasts.rejected, (state, action) => {\n      state.status = \"failed\";\n      state.error = action.error.message;\n    }).addCase(fetchPodcastDetails.pending, state => {\n      state.isFetchingDetails = true;\n    }).addCase(fetchPodcastDetails.fulfilled, (state, action) => {\n      state.isFetchingDetails = false;\n      state.podcastDetails = action.payload;\n      const podcastId = action.meta.arg;\n      // Comprobamos si los detalles del podcast están en la caché\n      const cachedDetails = state.podcastDetailsCache[podcastId];\n      const currentDate = new Date().toDateString();\n      if (cachedDetails && cachedDetails.lastFetchDate === currentDate) {\n        // Utilizamos los detalles almacenados en la caché\n        state.podcastDetails = cachedDetails.details;\n      } else {\n        // Almacenamos los nuevos detalles en la caché\n        state.podcastDetailsCache[podcastId] = {\n          lastFetchDate: currentDate,\n          details: action.payload,\n          summary: action.payload.summary,\n          podcastDetails: action.payload.podcastDetails\n        };\n        state.summary = action.payload.summary;\n        // state.podcastDetails = action.payload.podcastDetails;\n      }\n    }).addCase(fetchPodcastDetails.rejected, state => {\n      state.isFetchingDetails = false;\n    });\n  }\n});\nexport const {\n  updateFilter\n} = podcastSlice.actions;\nexport default podcastSlice.reducer;","map":{"version":3,"names":["createSlice","applyFilter","fetchPodcastDetails","fetchPodcasts","podcastSlice","name","initialState","podcasts","status","error","lastFetch","filter","filteredPodcasts","isFetchingDetails","podcastDetails","podcastDetailsCache","summary","downloadProgress","reducers","updateFilter","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","oneHourAgo","Date","now","rejected","message","podcastId","meta","arg","cachedDetails","currentDate","toDateString","lastFetchDate","details","actions","reducer"],"sources":["/Users/xavitorner/Downloads/inditex_podcaster/src/features/podcast/podcastSlice.js"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\n\nimport {\n  applyFilter,\n  fetchPodcastDetails,\n  fetchPodcasts,\n} from \"../../utils/utils\";\n\n\nconst podcastSlice = createSlice({\n  name: \"podcast\",\n  initialState: {\n    podcasts: [],\n    status: \"idle\",\n    error: null,\n    lastFetch: null,\n    filter: \"\",\n    filteredPodcasts: [],\n    isFetchingDetails: false,\n    podcastDetails: null,\n    podcastDetailsCache: {},\n    summary: null,\n    downloadProgress: 0,\n  },\n  reducers: {\n    updateFilter: (state, action) => {\n      state.filter = action.payload;\n      state.filteredPodcasts = applyFilter(state.podcasts, state.filter);\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchPodcasts.pending, (state) => {\n        state.status = \"loading\";\n      })\n      .addCase(fetchPodcasts.fulfilled, (state, action) => {\n        let oneHourAgo = Date.now() - 60 * 60 * 1000;\n\n        if (state.lastFetch > oneHourAgo) {\n          state.filteredPodcasts = applyFilter(state.podcasts, state.filter);\n        } else {\n          // Descargamos y almacenamos los nuevos podcasts en la caché\n          state.podcasts = action.payload;\n          state.lastFetch = Date.now();\n          state.filteredPodcasts = applyFilter(action.payload, state.filter);\n        }\n        state.status = \"succeeded\";\n      })\n      .addCase(fetchPodcasts.rejected, (state, action) => {\n        state.status = \"failed\";\n        state.error = action.error.message;\n      })\n      .addCase(fetchPodcastDetails.pending, (state) => {\n        state.isFetchingDetails = true;\n      })\n      .addCase(fetchPodcastDetails.fulfilled, (state, action) => {\n        state.isFetchingDetails = false;\n        state.podcastDetails = action.payload;\n\n        const podcastId = action.meta.arg;\n        // Comprobamos si los detalles del podcast están en la caché\n        const cachedDetails = state.podcastDetailsCache[podcastId];\n        const currentDate = new Date().toDateString();\n\n        if (cachedDetails && cachedDetails.lastFetchDate === currentDate) {\n          // Utilizamos los detalles almacenados en la caché\n          state.podcastDetails = cachedDetails.details;\n        } else {\n          // Almacenamos los nuevos detalles en la caché\n          state.podcastDetailsCache[podcastId] = {\n            lastFetchDate: currentDate,\n            details: action.payload,\n            summary: action.payload.summary,\n            podcastDetails: action.payload.podcastDetails,\n          };\n          state.summary = action.payload.summary;\n          // state.podcastDetails = action.payload.podcastDetails;\n        }\n      })\n      .addCase(fetchPodcastDetails.rejected, (state) => {\n        state.isFetchingDetails = false;\n      });\n  },\n});\n\nexport const { updateFilter } = podcastSlice.actions;\n\nexport default podcastSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}